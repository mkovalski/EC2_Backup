#!/usr/bin/python

import os
import argparse
import subprocess
import sys

#Global:
VERBOSE = False

def set_params():
    global VERBOSE
    parser = argparse.ArgumentParser(description='The ec2-backup tool performs a backup of the given directory into Amazon \
                 Elastic Block Storage (EBS).  This is achieved by creating a volume of \
                      the appropriate size, attaching it to an EC2 instance and finally copying \
                       the files from the given directory into this volume.')
    parser.add_argument('-m',  choices=['dd', 'rsync'], help="Use the given method to perform the backup. Valid methods are 'dd' and 'rsync'; default is 'dd'.")
    parser.add_argument('-v', help="Use the given volume instead of creating a new one.")
    parser.add_argument('dir', help="Directory to backup")

    args = parser.parse_args()
    
    #default should use dd, rsync otherwise
    if not args.m:
        method = 'dd'
    else:
        method = args.m

    volume_id = args.v
    directory = args.dir

    if os.environ.get('EC2_BACKUP_VERBOSE'):
        VERBOSE = True
    else: VERBOSE = False

    if os.environ.get('EC2_BACKUP_FLAGS_SSH'):
        key = os.environ.get('EC2_BACKUP_FLAGS_SSH')
    else: key = None

    if os.environ.get('EC2_BACKUP_FLAGS_AWS'):
        backup_flags = os.environ.get('EC2_BACKUP_FLAGS_AWS')
    else: backup_flags = None

    return (method, volume_id, directory, key, backup_flags)

def verbose_print(msg):
	if (VERBOSE):
		print (msg)

def check_volume_id(vol_id, vol_size):
	#check valid volume ID
	#Move to create_volume or a check_volume?
	#TODO: Check if attached already
	#TODO: Check size w/ result from check_dir
     
    #if no volume given, return and create one
    if not vol_id:
        return False 

    verbose_print("Checking volume %s given..." % vol_id)
    
    process = subprocess.Popen("aws ec2 describe-volumes --volume-ids %s " % vol_id, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    (output, error) = process.communicate()
    if process.returncode != 0:
        print error
        sys.exit(process.returncode)
    else:
        verbose_print("Volume %s OK" % vol_id)
        return True

def check_dir(directory):
    verbose_print("Checking directory %s" % directory)
    if os.path.isdir(directory):
       	verbose_print("Directory %s OK " % directory)
        #get and return size of directory in KB 
        process = subprocess.Popen("du -s %s | cut -f1" % directory, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, error) = process.communicate()

        if process.returncode != 0:
            print error
            sys.exit(process.returncode)

        #make sure variable can be an int
        try: 
            dir_size = int(output.strip())
        except Exception as e:
            print "Could not get directory size: \n %s\n exiting." % str(e)
            sys.exit(2)

        verbose_print("Directory is of size %sKB" % str(dir_size))
        return dir_size
    else:
        print "%s does not exits, please use a directory that exists for backup" % directory
        sys.exit(2)

def create_instance(backup_flags):
    verbose_print("Creating instance to attach volume...")
    ubuntu='ami-fce3c696'
    command = 'aws ec2 run-instances --image-id %s ' % ubuntu
    if backup_flags:
        command += backup_flags




def create_volume(vol_size): 
    verbose_print("Creating volume of size %sKB" % str(vol_size))
    return None

def use_volume(volume_id):
    #attach and mount volume
    pass

def launch_backup(method):
    #Do dd or rsync
    pass
def spin_down():
    #Clean up - shutdown instances and such
    pass

def main():
    method = ''
    volume_id = ''
    directory = ''

    #EC2_BACKUP_VERBOSE set as global
    #EC2_BACKUP_FLAGS_SSH or use Original
    key = None
    #EC2_BACKUP_FLAGS_AWS
    backup_flags = None
    #return code for program
    exit_code = 0
    #directory size
    dir_size = 0
    #Ubuntu instance
    instance=''



    #params set
    (method, volume_id, directory, key, backup_flags) = set_params()

   	#TODO: Check size of directory in check_dir
    dir_size = check_dir(directory)
     
    if not check_volume_id(volume_id, dir_size*2):
        volume_id = create_volume(dir_size*2)

   	instance = create_instance(backup_flags)
    use_volume(volume_id)
    launch_backup(method)
    spin_down()

if __name__ == "__main__":
    main()

